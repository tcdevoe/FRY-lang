\documentclass{article}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}
\usepackage{fixltx2e}

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{10} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{10}  % for normal

\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
\definecolor{codebg}{gray}{0.9}
\definecolor{comment}{gray}{0.4}

\lstset{
backgroundcolor=\color{codebg},
language=Python,
basicstyle=\ttm,
commentstyle=\color{comment}\ttm,
otherkeywords={Join, Sort, delim, Read, Write, ret, Layout, List, Table, true, false },             % Add keywords here
keywordstyle=\ttb\color{deepblue},
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false,            
breaklines=true
}



\title{FRY Language Reference}
\author{Tom DeVoe \\ tcd2123@columbia.edu}
\date{\today}

\begin{document}
\maketitle

\tableofcontents

\section{Introduction}
This document serves as a reference manual for the \textbf{FRY} Programming Language. \textbf{FRY} is a language designed for processing delimited text files.


\section{Lexical Conventions}
% In C sections are Tokens, Comments, Identifiers, Keywords, Constants

\subsection{Comments}
Single line comments are denoted by the character, \texttt{\#}. Multi-line comments are opened with \texttt{\#/} and closed with \texttt{/\#}. 
\\
\\
\texttt{\# This is a single line comment}
\\
\\
\texttt{\#/ This is a 
\\
				multi-line comment /\#}
\subsection{Identifiers}
An identifier is a string of letters, digits, and underscores. A valid identifier begins with an letter or an underscore. Identifiers are case-sensitive and can be at most 31 characters long.

\subsection{Keywords}

The following identifiers are reserved and cannot be used otherwise:

\vspace{5 mm}
\texttt{%
\begin{tabular}{ l l l l l }
int & str & float & bool  & Layout \\
List & Table & if & else & elif \\
in & Sort & not & typeof & and \\
or & continue & break & Write & Read \\
stdout & stderr & true & false
\end{tabular}
}

\subsection{Constants}
\label{sec:const}
There is a constant corresponding to each Primitive data type mentioned in \ref{sec:prims}.

\begin{itemize}
\item \textbf{Integer Constants} - Integer constants are whole base-10 numbers represented by a series of numerical digits (0 - 9) and an optional leading sign character($+$ or $-$). Absence of a sign character implies a positive number.

\item \textbf{Float Constants} - Float constants are similar to Integer constants in that they are base-10 numbers represented by a series of numerical digits. However, floats must include a decimal separator and optionally, a fractional part. Can optionally include a sign character ($+$ or $-$). Absence of a sign character implies a positive number.

\item \textbf{String Constants} - String constants are represented by a series of ASCII characters surrounded by quotation-marks (\texttt{" "}). Certain characters can be escaped inside of Strings with a backslash \textbf{'\'}. These characters are:

\begin{tabular}{ l | l | l }
\textbf{Character} & \textbf{Meaning} \\
\texttt{\textbackslash n } & Newline \\
\texttt{\textbackslash t} & Tab \\
\texttt{\textbackslash  \textbackslash} & Backslash \\
\texttt{\textbackslash " } & Double Quotes \\
\end{tabular}

\item \textbf{Boolean Constants} - Boolean constants can either have the case-sensitive value \emph{true} or \emph{false}.

\end{itemize}

\section{Syntax Notation}
Borrowing from the \emph{The C Programming Language} by Kernigan and Ritchie, syntactic categories are indicated by \emph{italic} type and literal words and characters in \texttt{typewriter} style. Optional tokens will be underscored by \textsubscript{\emph{opt}}.

\section{Meaning of Identifiers}
\subsection{Types}
\label{sec:types}
\subsubsection{Basic Types}
\label{sec:prims}
\begin{itemize}
\item \texttt{int} - 64-bit signed integer value
\item \texttt{str} - An ASCII text value
\item \texttt{float} - A double precision floating-point number
\item \texttt{bool} - A boolean value. Can be either \texttt{true} or \texttt{false}
\end{itemize}

\subsubsection{Compound Types}

\begin{itemize} 

\item \texttt{List} - an ordered collection of elements of the same data type. Every column in a \emph{Table} is represented as a List. Lists can be initialized to an empty list or one full of values like so:

\item \texttt{Layout} - a collection of named data types. Layouts behave similar to structs from C. Once a Layout is constructed, that layout may be used as a data type.  An instance of a Layout is referred to as a \emph{Record} and every table is made up of records of the Layout which corresponds to that table.

\item \texttt{Table} - a representation of a relational table. Every column in a table can be treated as a \emph{List} and every row is a record of a certain \emph{Layout}. Tables are the meat and potatoes of \textbf{FRY} and will be the focus of most programs.

\end{itemize}

\section{Conversions}
Certain operators can cause different basic data types to be converted between one another.
\subsection{Integer and Floating}
Integer and Floating point numbers can be converted between each other by simply creating a new identifier of the desired type and assigning the variable to be converted to that identifier. For example, to convert an integer to a floating point number:
\begin{lstlisting}
int i = 5
float f = i
Write(stdout, f)
# 5.0
\end{lstlisting}
When converting a floating point number to an integer, any fractional part will be truncated:
\begin{lstlisting}
float f = 5.5
int i = f
Write(stdout, i)
# 5
\end{lstlisting}
\subsection{Arithmetic Conversions}
For any binary operator with a floating point and an integer operator, the integer will be promoited to a float before the operation is performed.
\begin{lstlisting}
float f = 5.25
int i = 2
Write(stdout, f*i)
# 10.50
Write(stdout, f-i)
# 3.25
\end{lstlisting}
\subsection{String Conversions}
% Automatic conversions when concatenating int,float with string
String conversions are automatically performed when a non-string variable is concatenated with a string variable. 

\section{Expressions}
\label{sec:expr}
% Describes precedence of expression operators 
% Different types of expressions (Primary expression - a + b ; Postfix Expression - a++, etc.)
% Function Calls, Structure Referenxces (struct, union)
% Multiplicative/Additive Operators, conditional or, comma operator, etc. (other operators)
An expression in \textbf{FRY} is a combination of variables, operators, constants, and functions. The list of expressions below are listed in order of precedence. Every expression in a subsection shares the same precedence (ex. Identifiers and Constants have the same precedence).
%% TODO: Add more to intro %%
\subsection{Primary Expressions}
\begin{itshape}
\begin{tabbing}
	\= prima\=ry-expression : \\
		\>\> identifier \\
		\>\> constant \\ 
		\>\> (expression)
\end{tabbing}
\end{itshape}
Primary Expressions are either identifiers, constants, or parenthesized expressions. 
\subsubsection{Identifiers}
Identifiers types are specified during declaration by preceding that identifier by its type.  Identifiers can be used for any primitive or compound data types and any functions. 
\subsubsection{Constants}
Constants are either integer, string, float, or boolean constants as specified in \ref{sec:const}
\subsubsection{Parenthesized Expressions}
Parenthesized expression is simply an expression surrounded by parentheses. 

\subsection{Postfix Expression}
Operators in a postfix expression are grouped from left to right.
\begin{itshape}
\begin{tabbing}
	\= post\=fix-expression : \\
		\> \> primary-expression \\
		\>\> postfix-expression[expression(:expression)\textsubscript{opt}] \\		
		\>\> postfix-expression.\{expression(:expression)\textsubscript{opt}\}\\
		\>\> postfix-expression(argument-list\textsubscript{opt}) \\ 
		\> \> expression$--$ \\
		\> \> expression$++$ 
\end{tabbing}
\end{itshape}

\subsubsection{List Element Reference}
A list identifier followed by square brackets with an integer-valued expression inside denotes referencing the element at that index in the List. For instance \lstinline!MyLst[5]! would reference the $6^\mathrm{th}$ element of the List, \emph{MyLst}. Similarly, \lstinline!MyLst[n]! would reference the $n-1^\mathrm{th}$ element of MyLst. The type of this element is the same as the type of elements the List you are accessing contains. \\
Sublists can be returned by \emph{slicing} the list. By specifying the optional colon (':') and indices before and/or after, the list is sliced and a sublist of the original list is returned. If there is an integer before the semi-colon and none after, then a sublist is returned spanning from the integer to the end of the list. If there is an integer after the colon and none before, the a sublist is returned spanning from the beginning of the list to the integer index. If there is an integer before and after the colon, then a sublist is returned spanning from the first integer index to the second integer index.

\subsubsection{Layout Element Reference}
\label{sec:layoutref}
A layout identifier followed by a dot and an expression in braces ${ }$ references an element of a layout. The expression in the braces must either be \emph{(i)} the name of one of the member elements in the Layout you are accessing, such as \lstinline!MyLyt.{elem_name}! or \emph{(ii)} a integer reference to the $n^\mathrm{th}$ element of the Layout, i.e. \lstinline!MyLyt.{2}! would access the $1^\mathrm{st}$ member element. The type of the element returned will be the type that element was defined to be when the Layout was defined. If the member element you are accessing is itself a Layout, then the numeric and identifier references will both return a element of that Layout type. 
Sublayouts can be returned by \emph{slicing} the layout. Layout slicing syntax is mostly the same as the List slicing, except you can also specify element names as the indices on either side of the colon. This returns an instance of unamed layout type with unamed elements.

\subsubsection{Function Calls}
A function call consists of a function identifer, followed by parentheses with a possibly empty argument list contained. A copy is made of each object passed to the function, so the value of the original object will remained unchanged. Function declarations are discussed in \ref{sec:funcdec}.

\subsubsection{\emph{expression}$--$}
The double minus sign ('-') decrements an integer value by 1. The type of this expression must be integer.
\subsubsection{\emph{expression}$++$}
The double plus sign ('+') increments an integer value by 1. The type of this expression must be integer.

\subsection{Unary Operators}
Unary operators are grouped from right to left and include logical negation, incrementation, and decrementation operators.
\begin{tabbing}
	\= \emph{una}\=\emph{ry-expression :} \\
		\> \> \emph{postfix-expression} \\
		\>\> \texttt{not} \emph{unary-expression}\\
		\>\> \texttt{typeof}(\emph{primary-expression})
\end{tabbing}

\subsubsection{\texttt{not} \emph{expression}}
The \texttt{not} operator represents boolean negation. The type of the expression must be boolean.

\subsubsection{\texttt{typeof}(\emph{expression})}
The \texttt{typeof} operator returns the type of some identifier as a string.

\subsection{Multiplicative Operators}
These operators are grouped left to right.
\begin{itshape}
\begin{tabbing}
	\= multipl\=icative-expression : \\
		\>\> multiplicative-expression*multiplicative-expression \\		
		\>\> multiplicative-expression/multiplicative-expression \\
		\>\> multiplicative-expression/multiplicative-expression
\end{tabbing}
\end{itshape}

$*$ denotes mutltiplication, $/$ denotes division, and $\%$ returns the remainder after division (also known as the modulo). The expressions on either side of these operators must be integer or floating point expressions. If the operand of $/$ or $\%$ is 0, the result is undefined.

\subsection{Additive Operators}
These operators are grouped left to right.
\begin{itshape}
\begin{tabbing}
	\= addi\=tive-expression : \\
		\> \> multiplicative-expression \\
		\>\> additive-expression+additive-expression \\		
		\>\> additive-expression-additive-expression
\end{tabbing}
\end{itshape}

$+$ and $-$ denote addition and subtraction of the two operands respectively. Additionally the $+$ also denotes string concatenation. For $-$, the expressions on either side of the operators must be either integer or floating point valued. For $+$, the expressions can be integer, floating point or strings.

\subsection{Containment Operators}
\begin{tabbing}
	\= \emph{cont}\=\emph{ainment-expression} : \\
		\>\> \emph{additive-expression} \texttt{in} \emph{containment-expression} \\	
		\>\> \emph{additive-expression} \texttt{not in} \emph{containment-expression} 
\end{tabbing}
The containment operators check whether an element is contained in a List. The right operand must be a List and the left operand must be the same type as the elements that List contains. Both operators return a boolean value. If the element is in the list, then \texttt{in} returns \texttt{true} and if the element is not in the list, it returns \texttt{false}. \texttt{not in} returns the opposite values.

\subsection{Relational Operators}
\begin{itshape}
\begin{tabbing}
	\= relat\=ional-expression : \\
		\>\> additive-expression \\
		\>\> relational-expression$>$relational-expression \\		
		\>\> relational-expression$>=$relational-expression \\
		\>\> relational-expression$<$relational-expression \\
		\>\> relational-expression$<=$relational-expression 
\end{tabbing}
\end{itshape}

$>$ represents greater than, $>=$ represents greater than or equal to, $<$ represents less than, and $<=$ represents less than or equal to. These operators all return a boolean value corresponding to whether the relation is \texttt{true} or \texttt{false}. The type of each side of the operator should be either integer or floating point.

\subsection{Equality Operators}
\begin{itshape}
\begin{tabbing}
	\= equa\=lity-expression : \\
		\>\> relational-expression \\
		\>\> equality-expression $==$ equality-expression \\		
		\>\> equality-expression $!=$ equality-expression
\end{tabbing}
\end{itshape}
The $==$ operator compares the equivalence of the two operands and returns the boolean value \texttt{true} if they are equal, \texttt{false} if they are not. $!=$ does the opposite, \texttt{true} if they are unequal, \texttt{false} if they are equal. This operator compares the value of the identifier, not the reference for equivalence. The operands can be of any type, but operands of two different types will never be equivalent.

\subsection{Logical AND Operator}
The logical AND operator is grouped left to right.
\begin{tabbing}
	\= \emph{logi}\=\emph{cal-AND-expression} : \\
		\>\> \emph{equality-expression} \\
		\>\> \emph{logical-AND-expression} \texttt{and} \emph{logical-AND-expression} 
\end{tabbing}
The logical \emph{and} operator (\texttt{and}) only allows for boolean valued operands. This operator returns the boolean value true if both operands are true and false otherwise. 

\subsection{Logical OR Operator}
The logical OR operator is grouped left to right.
\begin{tabbing}
	\= \emph{logi}\=\emph{cal-OR-expression} : \\
		\>\> \emph{logical-AND-expression} \\
		\>\> \emph{logical-OR-expression} \texttt{or} \emph{logical-OR-expression} 
\end{tabbing}
The logical \emph{or} operator (\texttt{or}) only allows for boolean valued operands. This operator returns the boolean false if both operands are false and true otherwise.

\subsection{Assignment Expressions}
Assignment operators are grouped right to left.
\begin{itshape}
\begin{tabbing}
	\= assig\=nment-expression : \\
		\>\> logical-OR-expression \\
		\>\> primary-expression$=$assignment-expression 
\end{tabbing}
\end{itshape}
Assignment operators expect a variable identifier on the left and a constant or variable of the same type on the right side.


\section{Declarations}
% Type specifiers, struct union declarations, etc.

Declarations give the ability to define identifiers type and value.
\begin{itshape}
\begin{tabbing}
	\= decla\=rations : \\
		\> \> type-specifier declarator \\
		\>\> type-specifier declarator = initializer \\
\end{tabbing}
\end{itshape}

\subsection{Type Specifiers}
The different \emph{type-specifiers} available are:

\begin{tabbing}
	\= \emph{type}\=\emph{-specifiers} : \\
		\>\> \texttt{int} \\
		\>\> \texttt{str} \\
		\>\> \texttt{float} \\
		\>\> \texttt{bool} \\
		\>\> \texttt{List} \\
		\>\> \texttt{Layout} \\
		\>\> \texttt{Table} \\
\end{tabbing}

Exactly one type-specifier must be provided during a declaration. These types are described in more detail in \ref{sec:types}.

\subsection{List Declarations}
\label{sec:list}
A List is an ordered collection of elements of the same type. 
\begin{tabbing}
	\= \emph{List}\=\emph{-declarators} : \\
		\> \> \texttt{List} \emph{identifier} \\
		\>\> \texttt{List} \emph{identifier} \texttt{=} \emph{List-intializer } \texttt{} 
\end{tabbing}
A List declaration consists of the keyword \texttt{List} followed by an identifier for the list and optionally followed by an assignment from a \emph{List-initializer}.

\begin{tabbing}
	\= \emph{List}\=\emph{-intializer} : \\
		\> \> \texttt{[} \emph{List-declaration-list} \texttt{]} \\
		\>\> \texttt{\{}\emph{identifier-or-constant}\texttt{..}\emph{identifier-or-constant}\texttt{\}}
\end{tabbing}

A list-initializer intializes an unnamed list one of two ways. The first way defines each element of the list explicitly in square brackets using a \emph{List-declaration-list}. The second way requires two integer-valued \emph{identifier-or-constant} and generates a list ranging from the first \emph{identifier-or-constant} to the second \emph{identifier-or-constant}. The first \emph{identifier-or-constant} must be smaller than the second.

\begin{tabbing}
	\= \emph{List}\=\emph{-declaration-list} : \\
		\> \> \emph{constant-or-identifier} \\
		\>\> \emph{List-declaration-list, constant-or-identifier}
\end{tabbing}
\begin{tabbing}
	\= \emph{const}\=\emph{ant-or-identifier} : \\
		\> \> \emph{identifier} \\
		\>\> \emph{constant}
\end{tabbing}

The \emph{List-declaration-list} is a comma-separated list of identifiers or constants which define the values contained in that list. The associated type of the list is determined by the first element in the \emph{List-declaration-list}. It is invalid to add elements of a different type than the first element to that list. Declaring a List with no \emph{List-declaration-list} initializes an empty list with no associated type. The first element added to that list sets that List's type. 

For example,
\begin{lstlisting}
List l_int = [1,2,3,4]
List l_empty
List l_str = ["This", "is", "a", "list"]
List l_int = {1 .. 100}
\end{lstlisting}
declares a list containing the first for natural integers, an empty list, and a list of strings.

\subsection{Layout Declarations}
\label{sec:layout}
A Layout is a collection of optionally named members of various types.
\begin{tabbing}
	\= \emph{Layout}\=\emph{-intializers} : \\
		\> \> \texttt{Layout} \emph{identifier} \texttt{= \{} \emph{Layout-declaration-list, Print-specifier\textsubscript{opt}} \texttt{\}}
\end{tabbing}
A Layout declaration consists of the keyword \texttt{Layout} followed by an identifier and then an assignment from a  \emph{Layout-declaration-list} surrounded by curly braces. It is also optional to define a \emph{Print-specifier}, which is a string that defines how this Layout should be formatted when printed.
\begin{tabbing}
	\= \emph{Layout}\=\emph{-declaration-list} : \\
		\> \> \emph{Layout-element} \\
		\>\> \emph{Layout-declaration-list, Layout-element}
\end{tabbing}
\begin{tabbing}
	\= \emph{Layout}\=\emph{-element} : \\
		\> \> \emph{type-specifier}\texttt{:}\emph{identifier\textsubscript{opt}}
\end{tabbing}
\begin{tabbing}
	\= \emph{Print}\=\emph{-specifier} : \\
		\> \> \texttt{Print:}\emph{string-identifier-or-constant}
\end{tabbing}
The \emph{Layout-declaration-list} is a comma-separated list of \emph{Layout-elements} which defines the members of the Layout being declared. If no identifier is provided for an element, it can be accessed using the numeric Layout element reference as described in \ref{sec:layoutref}. If no \emph{Print-specifier} is defined, the elements are printed in the same order they were defined with any specified delimiter.

An instance of an already created layout is created using similar syntax to the declaration:

\begin{tabbing}
	\= \emph{Layout}\=\emph{-instance-creation} : \\
		\> \> \texttt{Layout} \emph{identifier} \emph{identifier} \\
		\>\> \texttt{Layout} \emph{identifier} \emph{identifier} \texttt{= \{} \emph{Layout-instance-list} \texttt{\}}
\end{tabbing}
The first identifier is the identifier of the Layout you are creating an instance of and the second is the identifier of this layout instance. 
\begin{tabbing}
	\= \emph{Layout}\=\emph{-instance-list} : \\
		\> \> \emph{constant-or-identifier} \\
		\>\> \emph{Layout-instance-list}\texttt{,} \emph{constant-or-identifier}
\end{tabbing}
The types of each element in the \emph{Layout-instance-list} must match the types of the members of the Layout type. Each member of the Layout instance declared is assigned the value of the \emph{constant-or-identifier} at that member's position. A mismatch between the member type and the constant or identifier type is considered an error.

Some examples of Layout declaration and creation are

\begin{lstlisting}
Layout date = { int: mon, int: day, int: year \
		Print:mon+"-"+day+"-"+year }
Layout date today = {10, 23, 2014}
Write(stdout, today)
# 10-23-2014
Layout date nextweek = { today.mon, today.day+7, \
				today.year}
Layout userinfo = {str: Fname, str: Lname, \		
			Layout date:bday}
\end{lstlisting}
In this example, date is defined as a Layout with three integer fields, for month, day, and year, and has a \emph{Print-specifier} defined. An instance of the date Layout is created with value 10-23-2014 and written to stdout using the \emph{Write} function. \emph{Write} is a built-in function which takes two arguments, an output (stdout,stderr, or string name of a file) and the object to be written. The date Layout instance \texttt{nextweek} is computed from today's date. The \texttt{userinfo} layout is created with the date Layout nested inside of it. 

\subsection{Table Declarations}
A Table represents a relational table of data. A Table is represented as a special type of Layout where every element of the layout is a List of the same size.

\begin{tabbing}
	\= \emph{Table}\=\emph{-intializers} : \\
		\> \> \texttt{Table} \emph{identifier}\texttt{(} \emph{identifier\textsubscript{opt}} \texttt{)}
\end{tabbing}

A table is initialized with the keyword \texttt{Table} followed by the table identifier and then an optional corresponding layout inside of parentheses. This Table will then have a List of each type in the corresponding layout. If the table is initialized without a corresponding layout, then the first layout instance added to this table will define the layout of its table. Since a Table is just a special type of layout, any layout operations can be performed on the table. For example, since any columns of the table are just List elements of the corresponding "Layout", they can be accessed using the Layout reference techniques explanined in \ref{sec:layoutref}. In particular, tables without a corresponding layout can be accessed using the numeric reference technique mentioned in that section.

Some Table declaration/initialization examples are:

\begin{lstlisting}
Layout date = { int: mon, int: day, int: year }
Table date_tbl(Layout date) = \
	Read("/home/tdevoe/dates.txt", ",")
\end{lstlisting}
\begin{lstlisting}
Table date_tbl2
Layout date myDate = {9,15,2012}
date_tbl2 = append(date_tbl2, myDate)
\end{lstlisting}

The first example illustrates creating a Table from a file using the built-in \emph{Read} function. \emph{Read} takes two arguments, the name of the file (or stdin,stdout) to read from, and a field delimiter. The second example illustrates initializing a table without a corresponding layout and then append a record to it, using the built-in \emph{Append} function. \emph{Append} takes as arguments a record and a table. As long as the record conforms to the table's associated Layout, the record is appended to the end of the table and the resulting table is returned. If the table doesn't have an associated layout yet, then the resulting table's layout is defined as the same as the record being appended.

\subsection{Function Declarations}
\label{sec:funcdec}
Function declarations are created along with their definition and have the following format:
\begin{tabbing}
	\= \emph{Function}\=\emph{-declarations} : \\
		\> \> \emph{type-specifier\textsubscript{opt} identifier}\texttt{(} \emph{parameter-list\textsubscript{opt}} \texttt{) 
\{ } \emph{function-definition} \texttt{\}}
\end{tabbing}

The type-specifier in the beginning of the function declaration specifies what type is returned by that function. The identifier that follows is the name of the function and will be referenced anytime that function should be called. 

Then there is a \emph{parameter-list}, i.e. a list of arguments, inside of parentheses.
\begin{tabbing}
	\= \emph{param}\=\emph{eter-list} : \\
		\> \> \emph{type-specifier identifier} \\
		\> \> \emph{parameter-list, type-specifier identifier}
\end{tabbing}
These arguments must be passed with the function whenever it is called.

After the arguments comes the function definition inside of curly braces. The definition can contain any number statements, expressions, and declarations. The one caveat is the definition must contain a \emph{ret} statement for the return type indicated. If no type-specifier is included, then there is no return type and there should be no \emph{ret} statement.

\section{Statements}
% Expression Statements, Flow Control, Iteration Stmt (for, while)
% Big one is list comprehension syntax
Unless otherwise described, statements are executed in sequence. Statements can be broken up into the following:
\begin{itshape}
\begin{tabbing}
	\= stat\=ement : \\
		\> \> expression-statement \\
		\>\> conditional-statement \\
		\> \> iteration-statement \\
		\> \> jump-statement \\
		\> \> set-builder-statement  
\end{tabbing}
\end{itshape}

Statements are separated by newlines and a series of statements will be called a \emph{statement-list}. A single statement can be spread across multiple lines by ending the line with a backslash ($\backslash$):
\begin{tabbing}
	\= \emph{stat}\=\emph{ement-list} : \\
		\> \> \emph{statement} \\
		\> \> \emph{statement-list} \texttt{$\backslash$n }\emph{statement}
\end{tabbing}


\subsection{Expression Statements}
Expressions statements make up the majority or statements:

\begin{itshape}
\begin{tabbing}
	\= expr\=ession-statements : \\
		\>\> expression
\end{tabbing}
\end{itshape}

An expression statement is made up of one or more expressions as defined in \ref{sec:expr}. After the entire statement is evaluated and all effects are completed, then the next statement is executed.

\subsection{Conditional Statements}
Conditional statements control the flow of a program by performing different sets of statements depending on some boolean value. 

\begin{tabbing}
	\= \emph{cond}\=\emph{itional-statements} : \\
		\> \> \texttt{if (}\emph{expression}\texttt{) \{} \emph{statement-list} \texttt{\}}\\
		\>\>  \texttt{if (}\emph{expression}\texttt{) \{} \emph{statement-list} \texttt{\}} \texttt{else}\texttt{ \{} \emph{statement-list} \texttt{\}} \\
		\>\>  \texttt{if (}\emph{expression}\texttt{) \{} \emph{statement-list} \texttt{\}} \texttt{elif (}\emph{expression}\texttt{) \{} \emph{statement-list} \texttt{\}}\texttt{ else} \texttt{ \{} \emph{statement-list} \texttt{\}} \\
\end{tabbing}

The three different conditional statements here all operate on a similar idea. Based on the value the expression in parentheses, which must be a boolean-valued expression, do or do not perform the statements in the curly braces. For an \emph{if} statement, if the expression in parentheses is true, then the statements inside the \emph{if} block is evaluated. If that \emph{if} statement has an attached \emph{else} block, then the else block is evaluated if the expression is false. 

If there are \emph{elif} blocks, then if any expression is true, the statement inside is evaluated and then conditional block is then jumped out of, i.e. no further expressions are evaluated. If no expression is true, then the \emph{else} block is evaluated if it exists.

\subsection{Iterative Statements}

\begin{tabbing}
	\= \emph{iter}\=\emph{ative-statements}: \\
	\> \> \texttt{for} \emph{identifier} \texttt{in} \emph{iterator} \texttt{\{} \emph{statement-list} \texttt{\}} \\
	\> \> \texttt{while (} \emph{expression} \texttt{)} \texttt{\{} \emph{statement-list} \texttt{\}}
\end{tabbing}

\subsubsection{for loop}

A \emph{for} loop executes the \emph{statement-list} once for each elements in an \emph{iterator}.

\begin{tabbing}
\= \emph{iter}\=\emph{ator}:\\
\>\> \emph{List-identifier} \\
\>\> \emph{List-intializer}
\end{tabbing}

An \emph{iterator} is either a predefined list or an unnamed \emph{List-initializer}, see \ref{sec:list} for more information on these. The first identifier in the for loop represents the element in the iterator that the loop is currently on and can be referenced as such in the scope of the for loop block.

\subsection{while loop}

The \emph{expression} inside of the parentheses of a while loop must be boolean-valued. The while loop repeatedly executes the \emph{statement-list} as long as the value of the expression is \texttt{true}.

\subsection{Jump Statements}
Jump statements allow the program to jump out of an iterative statement.

\begin{tabbing}
	\= \emph{jump}\=\emph{-statements}: \\
	\> \> \texttt{continue} \\
	\> \> \texttt{break}
\end{tabbing}
\texttt{continue} jumps to the start of the loop that the program is currently in. \texttt{break} jumps to the end and out of the loop the program is currently in.

\subsection{Set Builder Statements}
\label{sec:setbuild}
Set builder statements are a major part of \textbf{FRY} and can create new Tables from other tables using Set-builder notation.
\begin{tabbing}
	\= \emph{Set-bu}\=\emph{ilder-statements}: \\
	\> \> \texttt{[} \emph{return-layout} \texttt{|} \emph{elements-of} \texttt{;} \emph{expression} \texttt{]}
\end{tabbing}

A Set-builder-statement consists of a \emph{return-layout}, which is the format of the columns which should be returned, a \emph{elements-of}, which are identifiers for the records in up to two tables, and an \emph{expression} which is a boolean expression.

 The Set-builder notation evaluates the boolean expression for every record in the source table(s). If the boolean expression is true, then the \emph{return-layout} is returned for that record (or pair of records). The Set Builder statement finally returns a table composed of all of the records which passed the boolean condition, formatted with the \emph{return-layout}.

\begin{tabbing}
	\= \emph{elem}\=\emph{ents-of}: \\
	\> \> \emph{identifier} \texttt{<-} \emph{identifier} \\
	\> \> \emph{identifier} \texttt{<-} \emph{identifier} \texttt{,}  \emph{identifier} \texttt{<-} \emph{identifier}
\end{tabbing}

The \emph{elements-of} is comprised of two identifiers, the second identifier must be a valid table and the first is a name for the records in that table. The first identifier is only valid within the Set-builder statement. There can be either one or two pairs of identifiers, for one or two source tables.

\begin{tabbing}
	\= \emph{retu}\=\emph{rn-layout}: \\
	\> \> \emph{identifier} \\
	\> \> \texttt{\{} \emph{Layout-instance-list} \texttt{\}}
\end{tabbing}
The \emph{return-layout} must be a Layout type, and can be either a Layout \emph{identifier} or a \emph{Layout-instance-list} as described in \ref{sec:layout}.

\section{Scope}
Scope is handled simply in \textbf{FRY}, a variable cannot be referenced outside of the code block it was declared inside. In most cases, this block is denoted by curly braces (Conditional Statements, Iterative Statements, Function Definitions). One exception is the \emph{elements-of} section of a Set-builder statements \ref{sec:setbuild}, the scope for these variables are only inside the Set Builder statement (i.e. inside the square brackets). Any variable delcared outside of any code block is considered a global variable and can be referenced anywhere in the program.


\end{document}
